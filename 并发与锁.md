## 并发与锁

### 一、互斥锁

#### 1.1 什么是互斥锁

- 互斥锁是一种保护共享资源不被多个线程同时访问的同步机制。确保在同一时刻只有一个线程可以访问共享资源，避免数据竞争和不一致的问题。


#### 1.2 互斥锁的作用

- 保护共享数据。多线程的运行是不可预测的，多个线程可能会同时访问和修改共享资源，如果没有互斥锁保护可能导致共享资源不是我们期望的状态。比如一个计数器程序，多个线程同时对计数器进行加一操作，如果没有互斥锁，可能导致计数器的值不正确。

```C++
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>

std::mutex mtx; //全局互斥锁
int shared_resource = 0;	//共享资源

void increment()
{
    for (int i = 0; i < 10000; ++i)
    {
        std::lock_guard<std::mutex> lock(mtx);
        ++shared_resource;	 // 修改共享资源
    }
}

int main()
{
    const int num_threads = 10;
    std::vector<std::thread> threads;

    for (int i = 0; i < num_threads; ++i)
    {
        threads.emplace_back(increment);
    }
    for (auto& thread : threads)
    {
        thread.join();
    }
    std::cout << "final shared_resource: " << shared_resource << std::endl;
    return 0;
}
```

```c++
//运行结果，加了互斥锁的效果
//10个线程，每个线程都对共享资源加10000次，预期结果是100000
Final value of shared_resource: 100000

//某次运行结果，每次运行结果都不相同，这是没有加互斥锁的效果，也就是注释掉std::lock_guard<std::mutex> lock(mtx);
Final value of shared_resource: 94411
```

通过上述结果比对，我们可以看出互斥锁的加锁效果和必要性。如果不加互斥锁会导致竞争和数据不一致的问题，导致最终的数据不是我们所期望的。

### 二、读写锁

#### 1.1 什么是读写锁

- 在 C++ 中，读写锁（Read-Write Lock，也称为共享-互斥锁）是一种同步机制，用于允许多个线程同时读取共享资源，但写操作需要独占访问。这种锁特别适用于读操作频繁而写操作较少的场景，可以显著提高并发性能。

##### 1.1.1 读锁的特性

- 多个线程可以同时获取读锁。
- 读锁允许多个线程同时读取共享资源。
- 读锁的获取不会阻塞其他线程的读操作。

##### 1.1.2 写锁的特性

- 一次只能有一个线程获取写锁。
- 写锁的获取会阻塞其他线程的读操作和写操作，也就是一次只能有一个线程获取写锁。

#### 1.2 使用读写锁的原因

##### 1.2.1 提高并发性能

- 在许多实际应用中，对共享资源的访问模式通常是读操作频繁而写操作较少。比如说数据库查询操作远多于更新操作。缓存系统中，读取缓存数据的操作远多于写入缓存数据的操作。
- 在上述几种情况下，如果使用传统的互斥锁`std::mutex`，无论是读操作还是写操作，每次只有一个线程可以访问共享资源。这会导致大量的线程阻塞，降低系统的并发性能。

##### 1.2.2 优化资源利用率

- 在读多写少的场景中，读写锁可以更有效地利用系统资源。通过允许多个线程同时读取共享资源，系统可以更好地利用多核处理器的并行能力，提高整体性能。

##### 1.2.3 减少锁竞争

- 使用传统的互斥锁时，所有线程（无论是读操作还是写操作）都需要竞争同一个锁。这会导致大量的线程阻塞，尤其是在高并发的情况下。读写锁通过将锁分为读锁和写锁，减少了线程对锁的竞争，提高了系统的响应速度和吞吐量。

#### 1.3 适用场景

##### 1.3.1 数据库查询和更新

- 假设我们有一个多线程的数据库应用程序，其中大部分线程执行查询操作，只有少数线程执行更新操作。使用读写锁可以显著提高查询操作的性能，同时确保更新操作的原子性和一致性。像`MySQL`数据库它本身就提供了共享锁`S锁`和独占锁`X锁`。

##### 1.3.2 缓存系统

- 在缓存系统中，读取缓存数据的操作远多于写入缓存数据的操作。使用读写锁可以允许多个线程同时读取缓存数据，而写操作可以独占访问缓存，确保数据的一致性。

##### 1.3.3 日志系统

- 在日志系统中，读取日志的操作远多于写入日志的操作。使用读写锁可以允许多个线程同时读取日志，而写操作可以独占访问日志文件，确保日志的完整性和一致性。


#### 1.4 读写锁的使用示例

```c++
#include <iostream>
#include <thread>
#include <vector>
#include <shared_mutex>
#include <chrono>

class SharedResource
{
public:
    void read(int id)
    {
        std::shared_lock<std::shared_mutex> lock(m_mutex);
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟读操作   
        printf("Reader id is reading Value is: %d\n", id);
    }

    void write(int id)
    {
        std::unique_lock<std::shared_mutex> lock(m_mutex);
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟写操作
        m_value = id;
        printf("Writer id is writing Value is: %d\n", id);
    }

private:
    std::shared_mutex m_mutex;
    int m_value = 0;
};

void reader_function(SharedResource& resource, int id) 
{
    resource.read(id);
}

void writer_function(SharedResource& resource, int id)
{
    resource.write(id);
}

int main()
{
    SharedResource resource;
    std::vector<std::thread> threads;

    // 创建多个读线程
    for (int i = 0; i < 5; ++i)
    {
        threads.emplace_back(reader_function, std::ref(resource), i);
    }

    // 创建多个写线程
    for (int i = 0; i < 2; ++i)
    {
        threads.emplace_back(writer_function, std::ref(resource), i + 10);
    }

    for (auto& thread : threads)
    {
        thread.join();
    }

    return 0;
}
```
### 三、自旋锁

#### 3.1 什么是自旋锁

- 自旋锁（Spinlock）是一种同步原语，用于在多线程环境中保护共享资源的访问。与传统的互斥锁 `std::mutex`不同，自旋锁不会使线程进入阻塞状态，而是在尝试获取锁时不断循环（“自旋”），直到锁变为可用。

#### 3.2 自旋锁的工作原理

- 当一个线程尝试获取锁时，如果锁已经被其他线程占用，它不会将线程置于阻塞状态，而是不断循环检查锁的状态。
- 一旦自旋锁被释放从而变的可用，线程立即获取锁并继续执行。

#### 3.3 自旋锁的优点

##### 3.3.1 低延迟

- 自旋锁可以非常快速地获取和释放，适合于锁的持有时间非常短的场景。

##### 3.3.2 避免上下文切换

- 由于线程不会被挂起，因此不会触发上下文切换，减少了上下文切换的开销。如果我们使用互斥锁，线程由于获取不到锁而被阻塞，由运行态转变为阻塞态，这会发生CPU的上下文切换，是因为发生了系统调用。

#### 3.4 自旋锁的缺点

##### 3.4.1 CPU资源浪费

- 在锁持有时间比较长的场景中，锁被占用的时间较长，自旋锁会导致线程不断占用CPU资源，浪费CPU时间。

##### 3.4.2 可能导致饥饿

- 如果多个线程同时竞争，可能会导致某些线程长时间无法获取锁，从而出现饥饿现象。
- CPU 时间片竞争，自旋线程持续占用 CPU，导致其他等待锁的线程几乎没有机会运行。
- 优先级反转，如果一个低优先级线程持有锁，而高优先级线程在自旋，那么高优先级线程可能会一直忙等，反而影响系统调度，使中等优先级的线程（甚至持锁的线程）得不到 CPU。
- 自旋锁通常不保证先来先得。如果多个线程同时在自旋，谁能抢到锁完全取决于调度和竞争时机，某些线程可能一直“运气不好”而饥饿。

#### 3.3 代码实现伪自旋锁

```c++
#include <atomic>
#include <thread>
#include <iostream>

class Spinlock {
public:
    void lock()
    {
        bool expected = false;
        while (!m_flag.compare_exchange_strong(expected, true, std::memory_order_acquire))
        {
            expected = false; // 重置预期值
        }
    }

    void unlock()
    {
        m_flag.store(false, std::memory_order_release);
    }

private:
    std::atomic<bool> m_flag{false};
};

void critical_section(Spinlock& lock, int id)
{
    lock.lock();
    std::cout << "Thread " << id << " is in the critical section." << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作
    lock.unlock();
}

int main()
{
    Spinlock lock;
    std::vector<std::thread> threads;

    for (int i = 0; i < 10; ++i)
    {
        threads.emplace_back(critical_section, std::ref(lock), i);
    }

    for (auto& thread : threads)
    {
        thread.join();
    }

    return 0;
}
```

### 四、条件变量

#### 4.1 什么是条件变量

- C++ 中的条件变量（`std::condition_variable` 或 `std::condition_variable_any`）是一种线程同步机制，用于阻塞一个或多个线程，直到某个条件满足，通常和 `std::mutex` 搭配使用。它能避免忙等（自旋锁常见的问题），提高 CPU 利用率。

#### 4.2 条件变量的核心概念

##### 4.2.1 用于线程间的通信

- 一个线程等待某个条件（例如“队列不为空”），另一个线程满足条件后通知它。具体可以是这样的，我们有一个队列，其中存放整形数据。N个线程从队列中读取数据，N个线程写入数据到队列中。如果队列为空，那么读取数据的线程就被阻塞掉，直到写入数据的线程再次写入数据，队列中有数据，就通知被阻塞的读取数据的线程，使其被唤醒。

##### 4.2.2 避免轮询

- **条件变量**不像**自旋锁**那样一直检查条件，条件变量通过**挂起线程**直到条件满足才唤醒。

##### 4.2.3 基于等待队列

- 当线程调用 `wait()`方法 时，会自动释放互斥锁并进入等待队列。直到被唤醒，通过条件判断是否可以获取锁。

#### 4.3 条件变量的使用场景

##### 4.3.1 生产者-消费者模型

- 生产者线程，向共享缓冲区（比如队列）写入数据。
- 消费者线程，从共享缓冲区获取数据进行处理。
- **条件变量作用**
  - 当队列为空时，消费者不忙等，而是 `wait()` 等待条件（`!queue.empty()`）。
  - 当队列满时，生产者可以 `wait()`，直到有队列不满。
  - 生产者线程和消费者线程都可以用 `notify_one()` 或 `notify_all()` 唤醒对方。

##### 4.3.2 线程池工作线程同步

- 主线程提交任务 → 放入任务队列。
- 多个工作线程（消费者）竞争从队列取任务。
- 如果队列为空，工作线程需要休眠，直到有任务。

- **条件变量作用**
	- 工作线程 `wait()` 等待任务到来。
	- 当主线程提交新任务，`notify_one()` 或 `notify_all()` 唤醒空闲线程。
	- 保证线程池不会疯狂自旋。

#### 4.4 条件变量在生产者消费者模型中的使用

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>
#include <chrono>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> buffer;
const size_t MAX_BUFFER_SIZE = 10;
bool done = false; // 生产结束标志

void producer(int id, int count)
{
    for(int i = 0; i < count; ++i)
    {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []()
        { 
            return buffer.size() < MAX_BUFFER_SIZE; 
        }); // 队列满则等待

        buffer.push(i);
        std::cout << "Producer " << id << " produced " << i << "\n";
        lock.unlock();
        cv.notify_all(); // 通知消费者
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // 模拟生产耗时
    }
}

void consumer(int id)
{
    while(true)
    {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] 
        { 
            return !buffer.empty() || done; 
        }); // 队列为空且未结束则等待

        if(buffer.empty() && done)
        {
            break; // 没有数据且生产结束，退出
        }

        int item = buffer.front();
        buffer.pop();
        std::cout << "Consumer " << id << " consumed " << item << "\n";
        lock.unlock();
        cv.notify_all(); // 通知生产者
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟消费耗时
    }
}

int main()
{
    const int producerCount = 3;
    const int consumerCount = 4;
    const int itemsPerProducer = 10;

    std::vector<std::thread> producers;
    std::vector<std::thread> consumers;

    // 启动消费者
    for(int i = 0; i < consumerCount; ++i)
    {
        consumers.emplace_back(consumer, i);
    }

    // 启动生产者
    for(int i = 0; i < producerCount; ++i)
    {
        producers.emplace_back(producer, i, itemsPerProducer);
    }

    // 等待所有生产者完成
    for(auto& p : producers)
    {
        p.join();
    }

    // 通知消费者生产结束
    {
        std::lock_guard<std::mutex> lock(mtx);
        done = true;
    }
    cv.notify_all();

    for(auto& c : consumers)
    {
        c.join();
    }

    return 0;
}
```

### 五、原子操作

#### 5.1 原子操作的特点

- 原子操作是一种不可分割的操作，他在执行过程中不会被中断或被其他操作所干扰，通常用于并发编程中，确保多线程环境下操作的正确性，避免数据竞争和不一致的状态。
- 原子操作要么完全执行，要么完全不执行。他不允许其他线程在操作中介入，所有的操作都是一个完整的单元。
- 使用原子操作可以保证数据的一致性，每个线程都会看到数据的最新值，因为其操作是不可分割的，在修改一个变量的过程中是不会被打断的。

#### 5.2 C++中常见的原子操作

- ```c++
  std::atomic<int> x{42};	//定义一个原子变量x
  int value = x.load(std::memory_order_acquire);  // 原子读，value == 42
  x.store(42, std::memory_order_release);       // 原子写，设置release内存序
  int old1 = x.fetch_add(3);      // x += 3;
  int old2 = x.fetch_sub(1);      // x--
  ```

### 六、内存序

#### 6.1 C++11中的内存序枚举值

##### 6.1.1 memory_order_relaxed  

- releaxed内存序，仅保证原子操作，不对编译器和CPU进行限制，也就是还可能会发生指令重排的问题。
- 影响就是CPU或者编译器可能重排这个操作和其他指令的顺序。

##### 6.1.2 memory_order_release 

- 设定内存屏障（Memory barrier），保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面。

##### 6.1.3 memory_order_acquire 

- 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和release在不同线程中联合使用。

##### 6.1.4 memory_order_consume  

- 改进版的`memory_order_acquire` ，开销更小。

##### 6.1.5 memory_order_acq_rel  

- 它是`acquire`和`release`的结合，同时拥有它们俩提供的保证。比如你要对一个`atomic`自增1，同时希望该操作之前和之后的读取或写入操作不会被重新排序。


##### 6.1.6 memory_order_seq_cst   

- `memory_order_seq_cst`就像是`memory_order_acq_rel`的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到`memory_order_seq_cst`的原子操作，线程中该`memory_order_seq_cst`操作前的数据操作绝对不会被重新排在该`memory_order_seq_cst`操作之后，且该`memory_order_seq_cst`操作后的数据操作也绝对不会被重新排在`memory_order_seq_cst`操作前。

#### 6.2 内存序的作用

- 我们的程序最终会编译成二进制指令，也就是机器码，最终由CPU执行。指令排序指的是编译器和CPU在执行这些二进制指令时如何选择执行的顺序。
- 内存序这个东西还是限制的当前指令限制其他指令的执行顺序，确保其他指令在当前指令执行之前还是之后。
-  atomic的store和load也有相关的内存序的限制，会进行一个检查。非法的内存序会抛出一个异常。load和store分别是读和写操作，他们的内存序也限制了其他线程能否及时看到更新后的数据。
- 对于load操作，进行内存序检查，如图所示。
  ![img](assets/wps1.jpg) 
- 对于store操作，也会进行内存序检查，如图所示。
![img](assets/wps2.jpg) 

#### 6.3 内存序基本示例

```c++
#include <atomic>
#include <thread>
#include <iostream>
#include <vector>

std::atomic<int> data(0);            // 共享数据
std::atomic<bool> ready(false);      // 标志位，表示数据是否准备好

/*
生产者线程就做两件事，第一个是写入data，第二个是写入ready
写入ready，ready为true，就会通知消费者线程
*/
void producer()
{
    
    data.store(42, std::memory_order_relaxed);   // 写数据（可以放松，因为后面release保证可见性）
    //这里的release内存序就限制了data的写入不可能被重排到ready写入true之后
    ready.store(true, std::memory_order_release); // 发布数据，保证data对消费者可见
    std::cout << "Producer: data = 42\n";
}

/*消费者做两件事：
ready.load(memory_order_acquire)反复检查，直到 ready 为 true。
data.load(memory_order_relaxed)
*/
void consumer()
{
    //这里的acquire就限制了后续的data的读取不可能被重排到read读取为true之前，保证data读取到生产者写入的值
    while(!ready.load(std::memory_order_acquire))
    { 
        
    }
    int value = data.load(std::memory_order_relaxed); // 数据读取，此时保证看到producer写入的值
    std::cout << "Consumer: data = " << value << "\n";
}

int main()
{
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();
    return 0;
}
```



### 七、乐观锁

#### 7.1 什么是乐观锁

- 乐观锁是一种并发控制机制，它假设并发操作不会发生冲突，因此在操作之前不加锁。在操作完成时，再检查是否有冲突，如果有冲突则进行相应的处理（如重试、抛出异常等）。与悲观锁不同，乐观锁在大多数情况下无需加锁，从而减少了锁竞争，提高了系统性能。

#### 7.2 乐观锁的特点

- 假设竞争不会发生，一开始不会加锁，加锁的粒度小，允许多线程或多进程并发的访问共享资源。只有在修改资源时，才会检查其他线程是否修改了资源，检测的方式包括版本号或者是时间戳。如果其他线程没有修改资源，那么就提交，否则就回滚。

#### 7.3 乐观锁的使用场景

- 适用于冲突不频繁的场景，能够提升并发性能。

- 适用于写操作少，但读操作多的场景。

通过版本号和时间戳的方式差不多，都是在读取时，记录当前的版本号或者是时间戳，提交修改时判断版本号或者时间戳是否被修改，如果没有被修改则提交。否则报错或者是继续重试。

#### 7.4 乐观锁的实现示例

##### 7.4.1 C++中的乐观锁

```c++

```

##### 7.4.2 数据库中的乐观锁

```sql

```

### 八、悲观锁

#### 8.1 什么是悲观锁

#### 8.2 悲观锁的特点

#### 8.3 悲观锁的使用场景

#### 8.4 悲观锁的使用示例

#### 8.4.1 C++中的悲观锁

```c++

```

8.4.2 数据库中的悲观锁

```sql

```

特点

- 假设发生竞争，因此他在访问共享资源时总是先加锁，防止其他线程和进程访问，保证数据的一致性和安全性。

使用场景

- 数据库中的事务处理通常使用悲观锁。

- 适用于并发冲突频繁的场景，或者当数据一致性和完整性比性能更重要时。

### 九、锁分段

#### 9.1 锁分段的概念

#### 9.2 锁分段的特点

#### 9.3 锁分段的代码示例

### 十、固定加锁顺序

#### 10.1 什么是加锁顺序

#### 10.2 为什么要注意加锁顺序

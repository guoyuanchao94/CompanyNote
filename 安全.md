### 一、SQL注入

#### 1.1 什么是SQL注入

- SQL 注入是一种常见的网络攻击手段，攻击者通过在输入字段或请求中注入恶意的 SQL 语句，操控数据库执行意图之外的操作。

#### 1.2 SQL注入的原理

##### 1.2.1 输入验证不足

- 当Web应用程序没有正确验证用户输入时，攻击者可以在输入字段中插入SQL代码。

##### 1.2.2 拼接SQL语句

- 应用程序后端通常将用户输入与SQL查询拼接在一起，形成完整的数据库查询语句。

##### 1.2.3 执行恶意SQL

- 如果应用程序没有对输入进行适当的清理或转义，恶意SQL代码将被数据库服务器执行。

#### 1.3 SQL注入示例

- 当用户登录网站时，通常会输入用户名和密码。以下是一段正常的 SQL 查询代码

```sql
  SELECT * FROM users WHERE username = 'user1' AND password = 'password1';
```

- 如果攻击者输入的用户名：admin' -- ，密码是anything，SQL查询就会变成如下语句

```sql
SELECT * FROM users WHERE username = 'admin' -- AND password = 'anything';
-- 这样的话，-- 后面的语句都变成了注释，不会执行，攻击者就绕过了密码验证。
```

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    password VARCHAR(50)
);

INSERT INTO users (username, password) VALUES ('alice', 'alice123'),
('bob', 'bob123'),('admin', 'secret');

-- 普通查询是这样的
SELECT * FROM users WHERE username = 'alice' AND password = 'alice123';

-- SQL注入效果
-- 用户输入：
-- username = 'admin' OR 1=1 --
-- password = 任意

--  OR 1 = 1永远为真，where判断为真，返回相关的数据
SELECT * FROM users 
WHERE username = 'admin' OR 1=1 -- ' AND password = '任意';
```

#### 1.3 如何避免SQL注入

##### 1.3.1 参数化

- 参数化就是将SQL语句的执行和用户输入分开处理，用户的输入的参数不会被当成SQL语句的执行逻辑，而是只当初参数。
- 数据库先解析 SQL 语句本身的结构，把语法分析、查询计划生成完成。
- 将用户提供的值绑定到占位符上，数据库知道这是**数据值**，而不是 SQL 语句的一部分。

##### 1.3.2 预编译语句

- 预编译语句就是先将 SQL 语句的结构发送给数据库解析、编译生成执行计划并将其缓存起来，然后再绑定参数执行的查询方式。

#### 1.4 MySQL提供的预编译语句和参数化查询示例

```sql
-- 1. 创建预编译语句
PREPARE stmt FROM 'SELECT * FROM users WHERE username = ? AND password = ?';

-- 2. 设置参数，包含典型注入尝试
SET @u = "admin' OR 1=1 -- ";
SET @p = "anything'; DROP TABLE users; -- ";

-- 3. 执行预编译语句
EXECUTE stmt USING @u, @p;

-- 4. 清理语句
DEALLOCATE PREPARE stmt;

-- 这样查询到的结果为空，而不是像没有使用参数化和预编译语句时，返回整张表的数据
```

### 二、RBAC权限模型

#### 2.1 RBAC是什么

- RBAC即Role-Based Access Control， 基于角色的访问控制。
- 其核心思想是通过角色来管理用户权限，而不是直接给用户分配权限。它解决了大规模系统中，权限管理混乱的问题。
- 包括用户、角色、权限等几个基本组成部分。
- 用户就是系统中的操作主体，比如员工、管理员、客户等。
- 角色是一组权限的集合，代表某类职责或者职位，比如项目经理、财务总监、董事长等。
- 权限就是对系统资源进行操作的许可，比如读取、写入、修改等。

#### 2.2 RBAC的核心思想

- RBAC的核心思想就是将用户从权限管理中直接分离出来。
- 不需要单独管理用户的权限，只需要给用户分配合适的角色。
- 角色定义一次，多个用户共享，权限调整只需要修改角色即可。
- 可以实现多对多的关系，比如一个用户可以拥有多个角色，具体来说就是一个用户既可以是项目经理，也可以是部门长。一个角色可以被多个用户拥有，具体来说就是项目经理这个职位不止一个人担任。

#### 2.3 RBAC的类型

##### 2.3.1 RBAC0，最基本的RBAC模型

- 仅有用户、角色、权限三类实体
- 支持用户和角色多对多关系以及角色和权限多对多的关系。

##### 2.3.2 RBAC1，角色继承

- 支持角色之间的继承，比如“高级管理员”继承“低级管理员”权限。 

##### 2.3.3 RBAC2，约束规则，职责分离

- 可以设置约束，比如如一个用户不能同时拥有“审核”和“申请”角色。 

##### 2.3.4 RBAC3，即RBAC1+RBAC2

- 一个工业级 RBAC 模型，它能让角色形成层级（继承），还能通过约束规则保证安全，同时用户通过角色间接获得权限。 

#### 2.4 RBAC的优点

##### 2.4.1 集中管理，易于维护

- 用户不直接分配权限，而是分配角色。
- 权限变化只需要修改角色，无需逐个修改用户权限。

##### 2.4.2 安全性高

- 约束规则可以防止权限冲突和滥用。
- 用户只能通过角色获得权限，避免直接滥用资源。

##### 2.4.3 易于扩展和维护

- 当系统需要进行扩展或调整时，只需修改角色的权限分配，而无需改变具体的用户权限。

#### 2.5 RBAC的缺点

##### 2.5.1 **初期设计复杂**

- 需要事先规划好角色、权限和约束规则。
- 组织结构不清晰或频繁变动时，角色设计难度大。

##### 2.5.2 角色膨胀

- 系统功能复杂时，为适配各种权限组合可能产生大量角色。
- 导致管理成本增加，反而可能混乱。

##### 2.5.3 难以处理特殊情况

- RBAC模型对于不同角色的用户可能存在某些特殊需求或特权，如临时提升权限、临时改变角色等，这些特殊情况可能难以通过RBAC模型来满足。

### 三、Session/JWT

#### 3.1 Session

##### 3.1.1 基本概念

- Session 是一种服务器端的会话管理技术，用于在用户和服务器之间保持状态信息。Session 通常通过在服务器端存储会话数据来实现。

##### 3.1.2 工作原理

- 用户登录：用户提交用户名和密码，服务器验证通过后，会在服务器端创建一个Session对象，并分配一个唯一的Session ID。
- 存储Session：服务器将Session数据（例如用户 ID、角色等）存储在服务器内存、数据库或缓存（如 Redis）中。一般的话，客户端数量较多，还是将Session数据存储在缓存中，比如Redis。
- 下发Session ID：服务器将Session ID通过Set-Cookie（或其他方式）发送给客户端，客户端在后续请求中会携带这个Session ID。
- 验证请求：客户端每次请求时，服务器根据请求中的Session ID查找对应的 Session数据，确认用户身份和状态。
- Session 失效：Session通常有有效期，超时或用户登出后，服务器会销毁对应的Session数据。

#### 3.2 JWT

##### 3.2.1 基本概念

- JWT 即Json Web Token，是一种基于 JSON 的开放标准，用于在客户端和服务器之间传递信息。它是一个自包含的令牌（Token），可以验证用户身份并携带少量数据，常用于认证和授权。

##### 3.2.2 JWT结构

- JWT由三部分组成，使用点号（.）分隔，编码后形如Header.Payload.Signature。

- Header包含令牌类型和签名的算法（比如HMAC SHA256）：

- ```json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ```

- PayLoad包含用户信息、权限、过期时间等：

- ```json
  {
    "userId": 1001,
    "roles": ["Admin", "Finance"],
    "exp": 1692432000
  }
  ```

- Signature使用Header中指定的算法，通过密钥对Header 和Payload进行签名，用于验证令牌的完整性。

##### 3.2.3 工作原理

- 用户登录：用户提交凭据（如用户名和密码），服务器验证通过。

- 创建Header和Payload：服务器生成Header（指定算法）和Payload（包含用户信息）。对两者分别进行Base64Url编码。

- 生成签名：将编码后的Header和Payload拼接（用 . 分隔）。使用密钥和指定算法（如 HS256）生成签名。

- 下发JWT：服务器将JWT返回给客户端（通常通过JSON响应）。客户端存储JWT（通常在 localStorage或Cookie中）。

- 验证 JWT
  - 服务器从请求头中提取JWT，拆分为 Header、Payload和Signature。
  - 使用相同的密钥和Header中指定的算法，重新计算签名。
  - 比较计算出的签名与JWT中的 Signature是否一致。
  - 验证Payload中的字段，如exp（是否过期）、iss（发行者是否正确）。
  - 如果签名有效且未过期，返回请求资源；否则返回错误（如 401 Unauthorized）。


### 四、刷新令牌

##### 4.1 刷新令牌的作用

- 刷新令牌是一种特殊的令牌，专门用于从授权服务器获取新的访问令牌。主要是用于在访问令牌过期之后客户端无需重新登录，获取新的访问令牌。

##### 4.2 刷新令牌的工作原理

- 用户登录，服务器校验用户身份，校验成功。服务器生成JWT和刷新令牌，并且同时下发给客户端。

- 客户端每次请求资源，在HTTP请求头中携带访问令牌，服务端验证访问令牌。

- ```http
  Authorization: Bearer <access_token>
  ```

- 服务端验证访问令牌中的Payload中的exp字段，判断该访问令牌是否过期，如果过期则返回一个状态码比如`401 Unauthorized`给客户端，表示请求要求用户的身份认证，通知客户端访问令牌过期，登录失效。

- 客户端收到服务端返回的错误码之后，使用刷新令牌向刷新节点发起请求。服务端验证刷新令牌，验证其是否被篡改，并判断其是否仍在有效期内。如果验证通过则生成新的访问令牌和刷新令牌给客户端。

- 客户端收到新的访问令牌和刷新令牌之后更新本地存储，继续使用新的访问令牌进行后续请求。

### 五、限流

##### 5.1 限流的含义

- 限流是指通过限制客户端在特定时间段内对服务器的请求次数或频率，防止服务器资源被过度消耗。

##### 5.2 限流的目的

- 保护服务器：防止过多的请求导致服务器过载或宕机。
- 防止滥用：限制恶意用户通过频繁请求（如暴力破解、刷刷新令牌）攻击系统。

##### 5.3 应用场景

- 限制客户端每分钟调用刷新端点，比如说`/refresh`的次数，防止滥用刷新令牌。
- 限制用户每小时的登录尝试次数，防止暴力破解。

##### 5.4 限流的工作原理

- 识别客户端，通过Session或JWT机制识别客户端。
- 计数统计：服务端记录客户端在一定的时间内的请求次数。
- 限制规则：比如说“每分钟最多 10 次请求”或“每小时最多 5 次刷新”。
- 响应处理：判断请求是否在限制范围内，是就正常处理，不是的话就返回异常给客户端，比如返回`429 Too Many Requests`的状态码给客户端。

### 六、熔断

#### 6.1 什么是熔断机制

- 熔断机制的灵感来源于电气工程中的断路器，当电路过载时，断路器会自动断开以保护系统。在软件系统中，熔断机制用于处理服务间的调用，当某个服务出现故障（比如超时、错误率过高）时，熔断器会“断开”对该服务的调用，快速失败并避免进一步的资源浪费，同时给故障服务一定的恢复时间。

#### 6.2 为什么需要熔断

在微服务架构中，服务之间通过网络调用彼此，可能会面临以下问题：

- 服务不可用：目标服务宕机、响应缓慢或网络抖动。
- 级联故障：一个服务故障可能导致依赖它的其他服务也出现问题，最终引发雪崩效应。
- 资源耗尽：持续尝试调用故障服务会导致调用方的线程、连接池等资源被耗尽。

熔断机制通过主动隔离故障服务，防止问题扩散，并提高系统的容错能力。

#### 6.3 熔断的状态

##### 6.3.1 关闭状态

- 正常状态下，所有请求都会被发送到目标服务。
- 熔断器会监控请求的失败率（如超时、异常等）。
- 如果失败率超过阈值（比如连续多次调用失败），熔断器会切换到**打开状态**。

##### 6.3.2 打开状态

- 在此状态下，熔断器会阻止所有请求直接访问目标服务，直接返回错误或进行其他处理。
- 通常会设置一个时间窗口，等待一段时间后切换到**半开状态**。

##### 6.3.3 半开状态

- 熔断器允许少量请求尝试访问目标服务，以测试服务是否恢复。
- 如果这些请求成功，熔断器切换回**关闭状态**；如果仍然失败，则回到**打开状态**。

#### 6.4 熔断机制的具体作用

##### 6.4.1 防止故障扩散

- 当某个服务（或外部依赖）出现故障（如响应缓慢、宕机、错误率高）时，熔断器阻止客户端继续向故障服务发送请求，避免故障影响整个系统，导致级联失败或“雪崩效应”。

##### 6.4.2 快速失败

- 熔断器在检测到服务不可用时，直接返回预定义的降级结果（fallback），避免客户端浪费资源（如线程、连接池）在无意义的等待或重试上，提高响应速度。

##### 6.4.3 隔离故障

- 通过隔离不可靠的服务，熔断器确保系统的其他部分（未受影响的服务）继续正常运行，增强系统的模块化与独立性。

### 七、隔离舱

#### 7.1 基本概念

- 隔离舱（Isolation Chamber），在计算机安全领域，也称为沙箱（Sandbox）或隔离环境，是一种用于限制和隔离程序运行环境的安全机制。它的核心目标是通过将程序或进程置于一个受控的、隔离的环境中，防止其对系统其他部分造成潜在威胁，比如恶意代码的传播、数据泄露或系统破坏。
- 隔离舱是一种虚拟化或隔离技术，允许程序在与主机系统隔离的环境中运行。它通过限制程序对系统资源（如文件系统、网络、内存、硬件等）的访问，降低恶意行为的风险。隔离舱可以看作一个“密封舱”，程序在其中运行时，无法直接影响外部系统。

#### 7.2 隔离舱的工作原理

- **资源限制**：为程序分配有限的资源，如CPU、内存、存储空间等，防止其耗尽系统资源。
- **权限控制**：限制程序对文件系统、注册表、网络连接等的访问权限，仅允许必要的操作。
- **虚拟化**：在某些情况下，隔离舱通过虚拟化技术（如虚拟机或容器）为程序提供一个独立的运行环境，模拟真实系统的功能，但与实际系统隔离。
- **行为监控**：隔离舱通常会监控程序的行为，检测异常活动（如尝试访问未授权的文件或网络）。

- **环境隔离**：程序运行在一个与主机系统隔离的环境中，任何更改（如文件修改、配置变更）通常不会影响主机系统。

#### 7.3 隔离舱的类型

##### 7.3.1 操作系统级隔离

- **沙箱（Sandboxing）**：如Windows Sandbox，限制应用程序的权限，防止其访问敏感资源。
- **容器技术**：如Docker，通过容器化技术隔离应用程序，提供独立的运行时环境。

##### 7.3.2 虚拟机隔离

- 使用虚拟机（如VMware、VirtualBox）运行程序，虚拟机与主机系统完全隔离，适用于测试高风险软件或恶意代码分析。

##### 7.3.3 浏览器沙箱

- 现代浏览器（如Chrome、Firefox）使用沙箱机制，将每个标签页或插件运行在独立的进程中，防止恶意网页代码影响整个浏览器或系统。

#### 7.4 隔离舱的应用场景

- 恶意软件分析：安全研究人员在隔离舱中运行未知程序，观察其行为而无需担心系统被感染。
- 软件测试：开发者在隔离舱中测试新软件，确保其不会对系统造成意外影响。
- 云服务：云平台通过隔离舱为不同用户提供独立的运行环境，防止数据泄露或资源争用。
- 网络安全：浏览器使用沙箱隔离网页，防止恶意脚本攻击用户设备。

#### 7.5 隔离舱的优点

- 安全性高：有效防止恶意代码对系统的破坏，降低攻击面。
- 易于恢复：隔离舱中的更改通常是临时的，删除隔离环境即可恢复初始状态。
- 行为分析：便于监控和记录程序行为，有助于安全分析和调试。

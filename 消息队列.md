## 消息队列

消息队列即Message Queue，简称MQ

### 一、消息队列模式

#### 1.1 **点对点模式**

- 一个消息只能被一个消费者处理，生产者和消费者的数目是没有限制的。多个生产者可以向消息队列中发送消息，一个消息在被一个消费者处理的时候，这个消息会被**移除**或者是加锁，避免其他消费者处理这个消息。

#### 1.2 **发布/订阅模式**

##### 1.2.1 临时订阅模式

- 这种模式只有在消费者启动并且运行的时候才存在。一旦消费者退出，订阅就会取消并且未处理的消息也会被丢弃。

##### 1.2.2 持久订阅模式

- 这种订阅会一直存在，除非主动去删除。消费者退出后，消息系统会继续维护该订阅，并且后续消息可以被继续处理。

### 二、选择消息队列时的衡量标准

#### 2.1 **消息的顺序**

- 比如说发送到消息队列中的消息，消费时能否保证消费的顺序。比如说订单A先发送到消息队列，订单B再发送到消息队列，应该是先处理订单A，之后再处理订单B。

#### 2.2 **消息路由**

- 指的根据特定的规则或条件，将消息从消费者发送到消息队列中特定的消费者或者是消费者组的过程，主要是为了确保消息能够被正确的分发到需要处理他的服务或组件。比如说消息A只能被服务A处理，服务B不能处理消息A。

#### 2.3 **消息可靠性**

- 是否丢失消息的情况，比如订单A和订单B，都被发送到消息队列，这两个订单是否都能被处理。

#### 2.4 **消息时序**

- 包括“消息存活时间TTL”和“延迟预定的消息”。

- 消息存活时间TTL指的是消息在消息队列中可以存活的最大时间，如果超出TTL还没有被消费，他将会被标记为过期或者删除。
- 延迟／预定消息指的是消息被发送到消息队列中不立即被消费，而是等到一定的时间之后再被消费。使用这种方式可以实现定时任务。

#### 2.5 **消息留存**

- 指的是消息被消费之后是否保存在消息队列中，消息是否留存具有以下特点：

- **容错性增强**：如果消息被消费完之后还保存在消息队列中，如果消费者处理消息后出现故障，那么消息可以被重新消费，避免数据丢失。
- **支持重复处理**：在某些业务场景下，可能需要对同一条消息进行多次处理，消息留存可以支持这种场景。
- **审计和追踪**：消息留存可以用于审计和追踪，对于一些满足合规性的系统尤为重要。
- **存储成本增加**：保留消息需要更多的存储空间，这回增加存储成本。
- **管理的复杂性**：需要管理消息的声明周期，包括何时删除消息，如何标记已处理的消息。
- **性能影响**：存储大量的消息可能影响消息队列的性能。
- **数据一致性问题**：如果同一条消息被多个消费者处理，需要保证数据的一致性。
- **清理机制**：需要定期清理不再需要的消息，以免占用过多的资源。

#### 2.6 **容错性**

- 消费者处理消息失败后，如何处理，是不是存在一种机制可以保证消费失败的消息最终被成功消费。

#### 2.7 **伸缩**

- 当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。

#### 2.8 **吞吐量**

- 指的是消息队列的并发处理消息的能力。

### 三、消息队列一致性

#### 3.1 强一致性

- 强一致性指的是一旦一个写操作完成，任何读操作都必须返回这个写操作的最新值，就是说数据在所有节点上都是同步的。任何时刻所有节点数据完全一致，读写操作立即可见最新状态保证数据的实时同步。

#### 3.2 最终一致性

- 最终一致性指的是系统中的所有数据副本，在没有新的写入操作的情况下，最终都会达到一个一致的状态。但是，这个过程中，不同的副本可能会暂时出现数据不一致的情况。
- 写入后不立即同步，可能存在短暂的旧值。

### 四、Outbox模式

#### 4.1 解决问题

##### 4.1.1 数据库写入和消息发送的不一致

- Outbox模式解决了分布式系统中数据库操作和消息发送的一致性问题。
- 在我们的分布式系统中，一个操作通常包含两步，第一步是更新本地或者远程数据库，第二步是发送事件到消息队列中。
- 如果直接顺序执行，可能导致数据库写入成功，但是发送消息到消息队列失败。还有一种情况是写入数据库失败，但发送消息成功。以上两种情况都会导致不一致的问题。

##### 4.1.2 消息丢失或重复发送

- 消息丢失：传统方案可能因为网络问题导致消息没发出去。Outbox 模式使用轮询或异步发送，失败可以重试，保证消息最终会发出。
- 重复发送：消息可能被重复发送，Outbox 可以通过状态字段（如 `sent`）记录是否已经发送，结合消费端幂等性处理，避免重复造成问题。

#### 4.2 核心思想

##### 4.2.1 操作本地数据库

- 在同一个事务中，除了更新业务表的数据，同时写入一条待发送的消息到Outbox表中。比如订单服务更新订单状态，同时还写入一条创建订单的消息记录到Outbox表中。注意是在一个数据库事务中，执行上述操作，保证二者要么都成功，要么都失败。

##### 4.2.2 异步发送消息

- 后台启动一个任务，比如开启一个线程作为一个消息发送器定期的去轮询Outbox表，将未发送的消息发送掉。
- 发送消息成功后，更新或删除Outbox表中的记录，比如修改某个字段sent，0表示未发送，1表示已发送。

### 五、一致性与幂等

#### 5.1 一致性

#### 5.2 幂等

##### 5.2.1 概念

- 幂等指的是任意多次执行所产生的影响均与一次执行的影响相同。

##### 5.2.2 为什么需要幂等

- 我们在Outbox表中，比如说设置一个字段sent，0表示该消息没有投递到消息队列中，1表示该消息已经投递到消息队列中。我们在发送端是可以控制消息的发送次数。
- 当我们将消息投递到消息队列中，消息队列可能因为网络或其他原因导致消息被重复消费，比如说消息被库存服务两次消费。那么库存服务就需要幂等性，保证这两次重复的消费带来的结果是一样的，也就是不会减少两次库存。

- ```sql
  -- 首先判断该订单中是否已经被处理
  IF NOT EXISTS (SELECT 1 FROM processed_orders WHERE order_id = 100) THEN
      UPDATE inventory SET stock = stock - 1 WHERE product_id = 100; -- 更新库存表，减少特定商品的数量
      INSERT INTO processed_orders(order_id) VALUES(100);
  END IF;
  
  ```

### 六、分布式锁

#### 6.1 为什么需要分布式锁

- 我们的单主机程序中，多线程环境下，使用互斥锁或者是信号量等同步机制保证线程的同步执行，从而实现对共享资源的顺序访问。
- 由于业务发展需要，原来的单机部署的系统逐渐演化成多主机分布式系统。由于分布式系统多线程、多进程并且服务部署在不同的主机上，使得单主机情况下并发控制策略失效。为了解决这个问题，就需要跨主机的互斥机制来控制共享资源的访问。

#### 6.2 分布式锁的特点

- 一个方法在同一时间只能被一个主机的一个线程执行。
- 可重入特性，即获取锁的服务可以多次获取锁
- 具备锁失效机制，防止死锁。
- 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

#### 6.3 如何实现分布式锁

##### 6.3.1 使用数据库实现分布式锁

```sql
DROP TABLE IF EXISTS `method_lock`;
CREATE TABLE `method_lock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '主键',
  `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
  `desc` varchar(255) NOT NULL COMMENT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY `uidx_method_name` (`method_name`)
);
```

- 实现这么一个表，就是当我们想执行某个方法前，就使用这个方法向表中插入数据。因为数据库提供了加锁机制，其他服务执行这个函数的过程中会插入这么一条数据并加锁。多个服务之间同时调用该方法会因为数据库的加锁机制被阻塞，保证了同一时间只有一个服务的一个线程可以执行该方法。
- 执行完成后再删除相应的行数据，因为留存在数据库中也没有必要。

##### 6.3.2 使用Redis实现分布式锁

- 使用Redis实现分布式锁也是基于其具有很高的性能，读写速度快。

- Redis提供了一些命令，可以借助实现分布式锁。

- 主要是如下命令使用实现，假设服务A要执行某一方法访问共享资源。首先访问Redis缓存，使用SET命令设置lock_value，如果该键存在，则设置失败。如果该键不存在则设置成功，并且设置uuid作为值，标识该服务。并且给键设置TTL，避免服务崩溃却没有释放锁的问题。

  ```sql
  SET lock_value uuid NX EX TTL 
  // 其中lock_value表示锁资源，uuid用来标识该服务，NX表示Not Exist，即该键不存在才会设置，EX表示Expire，TTL表示该键的存活时间，这个时间不是随便设置的，要略大于业务执行时间。
  ```

- 完成操作后，检查自己是否持有锁，如果持有锁则将该键删除。

- 不过这种方式不能实现可重入机制，因为同一程序多次STE存在的键会返回nil。

- ```sql
  // 下面三条基础的命令可以实现可重入机制，但是操作不是原子的，所以也有问题，需要使用lua脚本实现原子操作
  //尝试第一次获取锁
  HSETNX lock_value owner client1
  //重入次数 +1
  HINCRBY lock_value count 1               
  //设置 20 秒过期
  EXPIRE lock_value 20     

```lua
-- KEYS[1] = 锁的 key
-- ARGV[1] = 客户端 ID (owner)
-- ARGV[2] = 过期时间（秒）

local key = KEYS[1]
local owner = ARGV[1]
local ttl = tonumber(ARGV[2])

-- 判断锁是否存在

if redis.call('EXISTS', key) == 0 then
    -- 尝试创建锁
    local ok = true
    if redis.call('HSET', key, 'owner', owner) == false then ok = false end
    if redis.call('HSET', key, 'count', 1) == false then ok = false end
    if redis.call('EXPIRE', key, ttl) == 0 then ok = false end

    if not ok then
        -- 任何一步失败，回滚
        redis.call('DEL', key)
        return {err="Lock creation failed, rolled back"}
    end
    return 1
end

-- 如果锁已存在且是自己持有，重入
local current_owner = redis.call('HGET', key, 'owner')
if current_owner == owner then
    local ok = true
    if redis.call('HINCRBY', key, 'count', 1) == false then ok = false end
    if redis.call('EXPIRE', key, ttl) == 0 then ok = false end

    if not ok then
        redis.call('DEL', key)
        return {err="Reentrant lock failed, rolled back"}
    end
    return 1
end

-- 锁被别人持有
return 0

```

```lua
-- 解锁代码如下所
-- KEYS[1] = 锁的 key
-- ARGV[1] = 客户端 ID
if (redis.call('EXISTS', KEYS[1]) == 0) then
    return 0
end

-- 这里要进行当前客户端是否还持有锁的判断，不能删除其他客户端的锁
if (redis.call('HGET', KEYS[1], 'owner') == ARGV[1]) then
    -- 持有锁就将获取锁的次数-1，直到当前客户端获取锁的次数减为0就删除锁
    local count = redis.call('HINCRBY', KEYS[1], 'count', -1)
    if (count == 0) then
        redis.call('DEL', KEYS[1])
    end
    return 1
end

return 0

```

